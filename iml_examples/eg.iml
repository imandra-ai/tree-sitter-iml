(* Simple IML example with functions, axiom, and theorem *)
[@@@import "./code-logician-examples/six_swiss.iml"]
[@@@import Six_swiss, "./code-logician-examples/six_swiss.iml"]

let add_one (x: int) : int = x + 1
[@@decomp top ()]

let is_positive (x: int) : bool = x > 0

let double (x: int) : int = x * 2

let decomp_double = double
[@@decomp top ~assuming: [%id is_positive] ~prune: true ()]

let square : int -> int = ()
[@@opaque]

let cube : int -> int = ()
[@@opaque]


let build_fib (f : int list) (i : int) (n : int) : int list =
  let rec helper curr_f curr_i =
    if curr_i > n then
      curr_f
    else
      match (List.nth (curr_i - 1) curr_f, List.nth (curr_i - 2) curr_f) with
      | (Some prev1, Some prev2) ->
          let new_f = curr_f @ [prev1 + prev2] in
          helper new_f (curr_i + 1)
      | _ -> curr_f
  [@@measure Ordinal.of_int (n - curr_i)]
  in
  helper f i

let good_measure x =
  x + 1
[@@measure Ordinal.of_int 1]


axiom positive_addition x =
  x >= 0 ==> add_one x > x

theorem double_add_one x =
  double (add_one x) = add_one (add_one x) + x
[@@by auto]

verify (fun x -> x > 0 ==> double x > x)

let double_non_negative_is_increasing (x: int) = x >= 0 ==> double x > x

verify double_non_negative_is_increasing

instance (fun x -> x >= 0 ==> not (double x > x))


let two_x = (let x = 1 in double x)

eval (double 2)
